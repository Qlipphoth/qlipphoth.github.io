<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>从零开始的 STL 实现记录：Adapter-2 | Qliphoth's Blog</title><meta name="author" content="Qliphoth"><meta name="copyright" content="Qliphoth"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="前言 上一节介绍了 iterator adapter 的内容，本节将介绍 adapter 家族的最后一部分成员：functor adapter。 functor adapter 是所有配接器中数量最庞大的一类，配接灵活程度非常高，通过它们之间的绑定、组合与修饰，几乎可以创造出各种表达式。 如同 container adapters 内藏了一个 container member 一样、或是像 rev">
<meta property="og:type" content="article">
<meta property="og:title" content="从零开始的 STL 实现记录：Adapter-2">
<meta property="og:url" content="https://qlipphoth.github.io/2023/10/30/2023-10-30-1/index.html">
<meta property="og:site_name" content="Qliphoth&#39;s Blog">
<meta property="og:description" content="前言 上一节介绍了 iterator adapter 的内容，本节将介绍 adapter 家族的最后一部分成员：functor adapter。 functor adapter 是所有配接器中数量最庞大的一类，配接灵活程度非常高，通过它们之间的绑定、组合与修饰，几乎可以创造出各种表达式。 如同 container adapters 内藏了一个 container member 一样、或是像 rev">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2023/08/18/cDqb7yXhnK6rkpN.jpg">
<meta property="article:published_time" content="2023-10-30T12:27:28.000Z">
<meta property="article:modified_time" content="2025-01-14T10:20:41.000Z">
<meta property="article:author" content="Qliphoth">
<meta property="article:tag" content="Cpp">
<meta property="article:tag" content="STL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/08/18/cDqb7yXhnK6rkpN.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2023/08/12/NkcT1PLmZVj5iY3.png"><link rel="canonical" href="https://qlipphoth.github.io/2023/10/30/2023-10-30-1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":500,"languages":{"author":"Author: Qliphoth","link":"Link: ","source":"Source: Qliphoth's Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '从零开始的 STL 实现记录：Adapter-2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-14 10:20:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 10 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom/beauty.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.css"><link rel="stylesheet" href="/css/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/08/12/NkcT1PLmZVj5iY3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">22</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw fas fa-comment-dots"></i><span> Talk</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw far fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/08/18/cDqb7yXhnK6rkpN.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Qliphoth's Blog"><span class="site-name">Qliphoth's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw fas fa-comment-dots"></i><span> Talk</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw far fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">从零开始的 STL 实现记录：Adapter-2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-10-30T12:27:28.000Z" title="Created 2023-10-30 12:27:28">2023-10-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-01-14T10:20:41.000Z" title="Updated 2025-01-14 10:20:41">2025-01-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Cpp/">Cpp</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Cpp/STL/">STL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">4.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>21min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="从零开始的 STL 实现记录：Adapter-2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言">前言</h2>
<p>上一节介绍了 iterator adapter 的内容，本节将介绍 adapter 家族的最后一部分成员：functor adapter。</p>
<p>functor adapter 是所有配接器中数量最庞大的一类，配接灵活程度非常高，通过它们之间的绑定、组合与修饰，几乎可以创造出各种表达式。</p>
<p>如同 container adapters 内藏了一个 container member 一样、或是像 reverse iterator （adapters）内藏了一个 iterator mermber 一样、或是像 stream iterator（adapters）内藏了一个 pointer to stream 一样，或是像 insert iterator （adapters）内藏了一个 pointer to container （并因而得以取其 iterator）一样，每一个 function adapters 也内藏了一个member object，其型别等同于它所要配接的对象（那个对象当然是一个“可配接的仿函数”，adaptable functor）。当 function adapter 有了完全属于自己的一份修饰对象（的副本）在手，它就成了该修饰对象（的副本）的主人，也就有资格调用该修饰对象（一个仿函数），并在参数和返回值上面动手脚了。</p>
<p>functor adapter 主要可以分为五类，以下将分别介绍。</p>
<h2 id="对返回值进行逻辑否定：not1、not2">对返回值进行逻辑否定：<code>not1</code>、<code>not2</code></h2>
<p>这两个配接器会分别将一个一元仿函数与一个二元仿函数的结果取反，由于被修饰的仿函数返回值类型为 <code>bool</code>，因此也可被称为谓词。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 仿函数配接器，用于将一个一元谓词取反</span></span><br><span class="line"><span class="comment">/// @tparam Predicate </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unary_negate</span>: <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Predicate::argument_type, <span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Predicate pred;  <span class="comment">// 将谓词作为成员变量，就能对其运算结果进行操作了</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">unary_negate</span><span class="params">(<span class="type">const</span> Predicate&amp; x)</span>: pred(x) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Predicate::argument_type&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> !<span class="built_in">pred</span>(x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 辅助函数，用于生成一个 unary_negate 对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> unary_negate&lt;Predicate&gt; <span class="title">not1</span><span class="params">(<span class="type">const</span> Predicate&amp; pred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unary_negate</span>&lt;Predicate&gt;(pred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 仿函数配接器，用于将一个二元谓词取反</span></span><br><span class="line"><span class="comment">/// @tparam Predicate</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binary_negate</span>: <span class="keyword">public</span> binary_function&lt;<span class="keyword">typename</span> Predicate::first_argument_type,</span><br><span class="line">                                            <span class="keyword">typename</span> Predicate::second_argument_type,</span><br><span class="line">                                            <span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Predicate pred;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">binary_negate</span><span class="params">(<span class="type">const</span> Predicate&amp; x)</span>: pred(x) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Predicate::first_argument_type&amp; x,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> <span class="keyword">typename</span> Predicate::second_argument_type&amp; y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">pred</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 辅助函数，用于生成一个 binary_negate 对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> binary_negate&lt;Predicate&gt; <span class="title">not2</span><span class="params">(<span class="type">const</span> Predicate&amp; pred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">binary_negate</span>&lt;Predicate&gt;(pred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对参数进行绑定：bind1st、bind2nd">对参数进行绑定：<code>bind1st</code>、<code>bind2nd</code></h2>
<p>这两个配接器分别将一个二元仿函数的第一个参数与第二个参数绑定为一个固定值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 仿函数配接器，用于将一个二元仿函数的第一个参数绑定为一个固定值，使其变成一元仿函数</span></span><br><span class="line"><span class="comment">/// @tparam Operation </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binder1st</span>: <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation::second_argument_type,</span><br><span class="line">                                       <span class="keyword">typename</span> Operation::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Operation op;  <span class="comment">// 将二元仿函数作为成员变量</span></span><br><span class="line">    <span class="keyword">typename</span> Operation::first_argument_type value;  <span class="comment">// 绑定的值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">binder1st</span>(<span class="type">const</span> Operation&amp; x, <span class="type">const</span> <span class="keyword">typename</span> Operation::first_argument_type&amp; y)</span><br><span class="line">        : <span class="built_in">op</span>(x), <span class="built_in">value</span>(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> Operation::result_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Operation::second_argument_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">op</span>(value, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 辅助函数，将二元仿函数的第一个参数绑定为一个固定值，使其变成一元仿函数</span></span><br><span class="line"><span class="comment">/// @param op 二元仿函数</span></span><br><span class="line"><span class="comment">/// @param x  绑定的值</span></span><br><span class="line"><span class="comment">/// @return  返回一个一元仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> binder1st&lt;Operation&gt; <span class="title">bind1st</span><span class="params">(<span class="type">const</span> Operation&amp; op, <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Operation::first_argument_type arg1_type;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">binder1st</span>&lt;Operation&gt;(op, <span class="built_in">arg1_type</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 仿函数配接器，用于将一个二元仿函数的第二个参数绑定为一个固定值，使其变成一元仿函数</span></span><br><span class="line"><span class="comment">/// @tparam Operation </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binder2nd</span>: <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation::first_argument_type,</span><br><span class="line">                                       <span class="keyword">typename</span> Operation::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Operation op;</span><br><span class="line">    <span class="keyword">typename</span> Operation::second_argument_type value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">binder2nd</span>(<span class="type">const</span> Operation&amp; x, <span class="type">const</span> <span class="keyword">typename</span> Operation::second_argument_type&amp; y)</span><br><span class="line">        : <span class="built_in">op</span>(x), <span class="built_in">value</span>(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> Operation::result_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Operation::first_argument_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">op</span>(x, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 辅助函数，将二元仿函数的第二个参数绑定为一个固定值，使其变成一元仿函数</span></span><br><span class="line"><span class="comment">/// @param op 二元仿函数</span></span><br><span class="line"><span class="comment">/// @param x  绑定的值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> binder2nd&lt;Operation&gt; <span class="title">bind2nd</span><span class="params">(<span class="type">const</span> Operation&amp; op, <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Operation::second_argument_type arg2_type;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">binder2nd</span>&lt;Operation&gt;(op, <span class="built_in">arg2_type</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用于函数合成：compose1、compose2">用于函数合成：<code>compose1</code>、<code>compose2</code></h2>
<p>这两个配接器用于合成一些仿函数的运算结果，具体说来：</p>
<ul>
<li><code>compose1(op1, op2)</code>：合成后的 <code>f(x)</code> 效果相当于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>o</mi><mi>p</mi><mn>1</mn><mo stretchy="false">(</mo><mi>o</mi><mi>p</mi><mn>2</mn><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x) = op1(op2(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span></li>
<li><code>compose2(op1, op2, op3)</code>：合成后的 <code>f(x)</code> 效果相当于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>o</mi><mi>p</mi><mn>1</mn><mo stretchy="false">(</mo><mi>o</mi><mi>p</mi><mn>2</mn><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>o</mi><mi>p</mi><mn>3</mn><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x) = op1(op2(x), op3(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mord">3</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 仿函数配接器，产生一个仿函数 f(x) = op1(op2(x))</span></span><br><span class="line"><span class="comment">/// @tparam Operation1</span></span><br><span class="line"><span class="comment">/// @tparam Operation2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation1</span>, <span class="keyword">class</span> <span class="title class_">Operation2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unary_compose</span>: <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation2::argument_type,</span><br><span class="line">                                           <span class="keyword">typename</span> Operation1::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Operation1 op1;</span><br><span class="line">    Operation2 op2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unary_compose</span>(<span class="type">const</span> Operation1&amp; x, <span class="type">const</span> Operation2&amp; y): <span class="built_in">op1</span>(x), <span class="built_in">op2</span>(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> Operation1::result_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Operation2::argument_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">op1</span>(<span class="built_in">op2</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 辅助函数，产生一个仿函数 f(x) = op1(op2(x))</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation1</span>, <span class="keyword">class</span> <span class="title class_">Operation2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> unary_compose&lt;Operation1, Operation2&gt; <span class="title">compose1</span><span class="params">(<span class="type">const</span> Operation1&amp; op1, <span class="type">const</span> Operation2&amp; op2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unary_compose</span>&lt;Operation1, Operation2&gt;(op1, op2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 仿函数配接器，产生一个仿函数 f(x) = op1(op2(x), op3(x))</span></span><br><span class="line"><span class="comment">/// @tparam Operation1</span></span><br><span class="line"><span class="comment">/// @tparam Operation2</span></span><br><span class="line"><span class="comment">/// @tparam Operation3</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation1</span>, <span class="keyword">class</span> <span class="title class_">Operation2</span>, <span class="keyword">class</span> <span class="title class_">Operation3</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binary_compose</span>: <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation2::argument_type,</span><br><span class="line">                                            <span class="keyword">typename</span> Operation1::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Operation1 op1;</span><br><span class="line">    Operation2 op2;</span><br><span class="line">    Operation3 op3;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">binary_compose</span>(<span class="type">const</span> Operation1&amp; x, <span class="type">const</span> Operation2&amp; y, <span class="type">const</span> Operation3&amp; z)</span><br><span class="line">        : <span class="built_in">op1</span>(x), <span class="built_in">op2</span>(y), <span class="built_in">op3</span>(z) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> Operation1::result_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Operation2::argument_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">op1</span>(<span class="built_in">op2</span>(x), <span class="built_in">op3</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 辅助函数，产生一个仿函数 f(x) = op1(op2(x), op3(x))</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation1</span>, <span class="keyword">class</span> <span class="title class_">Operation2</span>, <span class="keyword">class</span> <span class="title class_">Operation3</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> binary_compose&lt;Operation1, Operation2, Operation3&gt; </span></span><br><span class="line"><span class="function"><span class="title">compose2</span><span class="params">(<span class="type">const</span> Operation1&amp; op1, <span class="type">const</span> Operation2&amp; op2, <span class="type">const</span> Operation3&amp; op3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">binary_compose</span>&lt;Operation1, Operation2, Operation3&gt;(op1, op2, op3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用于函数指针与成员函数指针：ptr-fun、mem-fun、mem-fun-ref">用于函数指针与成员函数指针：<code>ptr_fun</code>、<code>mem_fun</code>、<code>mem_fun_ref</code></h2>
<p>这两种配接器使我们能够将一般函数与成员函数当做仿函数使用。</p>
<p>一般函数当做仿函数传给STL算法，就语言层面本来就是可以的，就好像原生指针可被当做迭代器传给 STL 算法一样；至于成员函数，虽然说要麻烦一些但仍然可以使用匿名函数（lambda）的方式传给 STL 的算法。但如果你不使用这里所说的两个配接器先做一番包装，你所使用的那个一般函数将无配接能力、也就无法和前数小节介绍过的其它配接器接轨。</p>
<p>可能部分读者对于“可配接能力”这一概念还不是很理解，这里就说一下博主的理解：</p>
<p>首先，STL 中针对仿函数与配接器的设计是怎样的？没错，通过模板参数推导以及继承的方式规范了各种仿函数的接口。具体说来，每个一元仿函数（unary）都继承自 <code>unary_function</code>，从而可以通过 <code>argument_type</code> 以及 <code>result_type</code> 来获得仿函数的参数以及返回值的型别信息；对于二元仿函数（binary）来说也是如此。因此，各种配接器才能在一个抽象的层面上工作，并且可以不断地组合或配接。</p>
<p>以 <code>binary_compose::operator()</code> 为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typename</span> Operation1::result_type </span></span><br><span class="line"><span class="function"><span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Operation2::argument_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">op1</span>(<span class="built_in">op2</span>(x), <span class="built_in">op3</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于所有的仿函数全都统一了接口，因此我们便可以用 <code>Operation1::result_type</code> 取得返回值类型，<code>Operation2::argument_type</code> 取得参数类型。而不用关心具体的仿函数是什么样的；进一步地，以 <code>compose2()</code> 为例，其返回值类型为 <code>binary_compose&lt;Operation1, Operation2, Operation3&gt;</code> 而 <code>binary_compose</code> 又是继承于 <code>unary_function</code>。因此被配接器修饰后的结果依然可以通过 <code>first_argument_type</code> 和 <code>result_type</code> 等型别萃取出信息，从而可以继续配接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation1</span>, <span class="keyword">class</span> <span class="title class_">Operation2</span>, <span class="keyword">class</span> <span class="title class_">Operation3</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> binary_compose&lt;Operation1, Operation2, Operation3&gt; </span></span><br><span class="line"><span class="function"><span class="title">compose2</span><span class="params">(<span class="type">const</span> Operation1&amp; op1, <span class="type">const</span> Operation2&amp; op2, <span class="type">const</span> Operation3&amp; op3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">binary_compose</span>&lt;Operation1, Operation2, Operation3&gt;(op1, op2, op3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这大概就是“可配接能力”的体现了吧，反观普通函数与成员函数，它们自然不会继承于 <code>unary_function</code> 或 <code>binary_function</code> 类型，虽然也可以通过函数指针的方式传给 STL 算法，但还是失去了配接能力，即不能再与其他的 STL 仿函数与配接器“合作”。</p>
<h3 id="用于函数指针：ptr-fun">用于函数指针：<code>ptr_fun</code></h3>
<p>通过模板参数推导萃取出函数指针的参数，并通过继承，统一对外的接口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 函数配接器，将一个一元函数包装为仿函数</span></span><br><span class="line"><span class="comment">/// @tparam Arg 一元函数的参数类型</span></span><br><span class="line"><span class="comment">/// @tparam Result 一元函数的返回值类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pointer_to_unary_function</span>: <span class="keyword">public</span> unary_function&lt;Arg, Result&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Result</span> (*ptr)(Arg);  <span class="comment">// 函数指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">pointer_to_unary_function</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">pointer_to_unary_function</span><span class="params">(Result (*x)(Arg))</span>: ptr(x) &#123;</span>&#125;</span><br><span class="line">    <span class="function">Result <span class="title">operator</span><span class="params">()</span><span class="params">(Arg x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ptr</span>(x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 将一个一元函数包装为仿函数</span></span><br><span class="line"><span class="comment">/// @param x  一元函数</span></span><br><span class="line"><span class="comment">/// @return  仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pointer_to_unary_function&lt;Arg, Result&gt; <span class="title">ptr_fun</span><span class="params">(Result (*x)(Arg))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pointer_to_unary_function</span>&lt;Arg, Result&gt;(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 函数配接器，将一个二元函数包装为仿函数</span></span><br><span class="line"><span class="comment">/// @tparam Arg1 二元函数的第一个参数类型</span></span><br><span class="line"><span class="comment">/// @tparam Arg2 二元函数的第二个参数类型</span></span><br><span class="line"><span class="comment">/// @tparam Result 二元函数的返回值类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>, <span class="keyword">class</span> <span class="title class_">Arg2</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pointer_to_binary_function</span>: <span class="keyword">public</span> binary_function&lt;Arg1, Arg2, Result&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Result</span> (*ptr)(Arg1, Arg2);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">pointer_to_binary_function</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">pointer_to_binary_function</span><span class="params">(Result (*x)(Arg1, Arg2))</span>: ptr(x) &#123;</span>&#125;</span><br><span class="line">    <span class="function">Result <span class="title">operator</span><span class="params">()</span><span class="params">(Arg1 x, Arg2 y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ptr</span>(x, y); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 将一个二元函数包装为仿函数</span></span><br><span class="line"><span class="comment">/// @param x  二元函数</span></span><br><span class="line"><span class="comment">/// @return  仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>, <span class="keyword">class</span> <span class="title class_">Arg2</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pointer_to_binary_function&lt;Arg1, Arg2, Result&gt; <span class="title">ptr_fun</span><span class="params">(Result (*x)(Arg1, Arg2))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pointer_to_binary_function</span>&lt;Arg1, Arg2, Result&gt;(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用于成员函数指针：mem-fun、mem-fun-ref">用于成员函数指针：<code>mem_fun</code>、<code>mem_fun_ref</code></h3>
<p>成员函数指针的配接器相比于普通函数指针的配接器实现起来有一些不同的地方：</p>
<ol>
<li>首先，无任何参数的成员函数被修饰后会变为 <code>unary_function</code> 类型，而有一个参数的成员函数会变为 <code>binary_function</code>。</li>
</ol>
<p>这主要是因为成员函数是通过该类的实例化对象来调用的，熟悉成员函数的读者都知道，成员函数在调用时会隐式地传递一个 <code>this</code> 指针指向当前对象。因此，即使是调用无参数的成员函数，也需要通过 <code>obj-&gt;f()</code> 或 <code>obj.f()</code> 的方式调用，因此在重载 <code>operator()</code> 时一定需要传入一个该类型的对象，再由该对象调用成员函数。</p>
<ol start="2">
<li>由于各种条件的排列组合，成员函数指针配接器一共要实现 8 种不同的版本：</li>
</ol>
<p>具体说来：（1）无任何参数 vs 有一个参数 （2）通过指针调用 vs 通过引用调用 （3）const 成员函数 vs 非 const 成员函数。组合下来共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">2^3 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span> 个不同的类模板，为了方便使用，STL 也提供了 8 个不同版本的辅助函数，这些辅助函数通过函数重载来实现不同条件下的匹配，十分方便。</p>
<blockquote>
<p>容器中存放的既有可能是对象的指针，也有可能是对象本身，因此需要分出通过指针调用与通过引用调用两种不同的版本。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 无任何参数，通过指针调用，non-const 成员函数</span></span><br><span class="line"><span class="comment">/// @tparam S 返回值类型</span></span><br><span class="line"><span class="comment">/// @tparam T 成员函数所属的类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mem_fun_t</span>: <span class="keyword">public</span> unary_function&lt;T*, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun_t</span><span class="params">(S (T::*pf)())</span>: f(pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(T* p)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (p-&gt;*f)(); &#125;  <span class="comment">// 转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">S</span> (T::*f)();  <span class="comment">// 内部成员，指向成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 无任何参数，通过指针调用，const 成员函数</span></span><br><span class="line"><span class="comment">/// @tparam S 返回值类型</span></span><br><span class="line"><span class="comment">/// @tparam T 成员函数所属的类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">const_mem_fun_t</span>: <span class="keyword">public</span> unary_function&lt;<span class="type">const</span> T*, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">const_mem_fun_t</span><span class="params">(S (T::*pf)() <span class="type">const</span>)</span>: f(pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T* p)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (p-&gt;*f)(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">S</span> (T::*f)() <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 无任何参数，通过引用调用，non-const 成员函数</span></span><br><span class="line"><span class="comment">/// @tparam S 返回值类型</span></span><br><span class="line"><span class="comment">/// @tparam T 成员函数所属的类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mem_fun_ref_t</span>: <span class="keyword">public</span> unary_function&lt;T, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun_ref_t</span><span class="params">(S (T::*pf)())</span>: f(pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp; r)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (r.*f)(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">S</span> (T::*f)();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 无任何参数，通过引用调用，const 成员函数</span></span><br><span class="line"><span class="comment">/// @tparam S 返回值类型</span></span><br><span class="line"><span class="comment">/// @tparam T 成员函数所属的类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">const_mem_fun_ref_t</span>: <span class="keyword">public</span> unary_function&lt;T, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">const_mem_fun_ref_t</span><span class="params">(S (T::*pf)() <span class="type">const</span>)</span>: f(pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; r)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (r.*f)(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">S</span> (T::*f)() <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 一个参数，通过指针调用，non-const 成员函数</span></span><br><span class="line"><span class="comment">/// @tparam S 返回值类型</span></span><br><span class="line"><span class="comment">/// @tparam T 成员函数所属的类</span></span><br><span class="line"><span class="comment">/// @tparam A 参数类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mem_fun1_t</span>: <span class="keyword">public</span> binary_function&lt;T*, A, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun1_t</span><span class="params">(S (T::*pf)(A))</span>: f(pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(T* p, A x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (p-&gt;*f)(x); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">S</span> (T::*f)(A);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 一个参数，通过指针调用，const 成员函数</span></span><br><span class="line"><span class="comment">/// @tparam S 返回值类型</span></span><br><span class="line"><span class="comment">/// @tparam T 成员函数所属的类</span></span><br><span class="line"><span class="comment">/// @tparam A 参数类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">const_mem_fun1_t</span>: <span class="keyword">public</span> binary_function&lt;<span class="type">const</span> T*, A, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">const_mem_fun1_t</span><span class="params">(S (T::*pf)(A) <span class="type">const</span>)</span>: f(pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T* p, A x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (p-&gt;*f)(x); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">S</span> (T::*f)(A) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 一个参数，通过引用调用，non-const 成员函数</span></span><br><span class="line"><span class="comment">/// @tparam S 返回值类型</span></span><br><span class="line"><span class="comment">/// @tparam T 成员函数所属的类</span></span><br><span class="line"><span class="comment">/// @tparam A 参数类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mem_fun1_ref_t</span>: <span class="keyword">public</span> binary_function&lt;T, A, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun1_ref_t</span><span class="params">(S (T::*pf)(A))</span>: f(pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp; r, A x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (r.*f)(x); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">S</span> (T::*f)(A);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 一个参数，通过引用调用，const 成员函数</span></span><br><span class="line"><span class="comment">/// @tparam S 返回值类型</span></span><br><span class="line"><span class="comment">/// @tparam T 成员函数所属的类</span></span><br><span class="line"><span class="comment">/// @tparam A 参数类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">const_mem_fun1_ref_t</span>: <span class="keyword">public</span> binary_function&lt;T, A, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">const_mem_fun1_ref_t</span><span class="params">(S (T::*pf)(A) <span class="type">const</span>)</span>: f(pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; r, A x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (r.*f)(x); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">S</span> (T::*f)(A) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应的辅助函数，使用了重载所以只需要使用 <code>mem_fun()</code> 与 <code>mem_fun_ref()</code> 两个对外接口即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">mem_fun_t</span>&lt;S, T&gt; <span class="title">mem_fun</span><span class="params">(S (T::*f)())</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mem_fun_t</span>&lt;S, T&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const_mem_fun_t</span>&lt;S, T&gt; <span class="title">mem_fun</span><span class="params">(S (T::*f)() <span class="type">const</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_mem_fun_t</span>&lt;S, T&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">mem_fun_ref_t</span>&lt;S, T&gt; <span class="title">mem_fun_ref</span><span class="params">(S (T::*f)())</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mem_fun_ref_t</span>&lt;S, T&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const_mem_fun_ref_t</span>&lt;S, T&gt; <span class="title">mem_fun_ref</span><span class="params">(S (T::*f)() <span class="type">const</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_mem_fun_ref_t</span>&lt;S, T&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">mem_fun1_t</span>&lt;S, T, A&gt; <span class="title">mem_fun</span><span class="params">(S (T::*f)(A))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mem_fun1_t</span>&lt;S, T, A&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const_mem_fun1_t</span>&lt;S, T, A&gt; <span class="title">mem_fun</span><span class="params">(S (T::*f)(A) <span class="type">const</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_mem_fun1_t</span>&lt;S, T, A&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">mem_fun1_ref_t</span>&lt;S, T, A&gt; <span class="title">mem_fun_ref</span><span class="params">(S (T::*f)(A))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mem_fun1_ref_t</span>&lt;S, T, A&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const_mem_fun1_ref_t</span>&lt;S, T, A&gt; <span class="title">mem_fun_ref</span><span class="params">(S (T::*f)(A) <span class="type">const</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_mem_fun1_ref_t</span>&lt;S, T, A&gt;(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<p>以下简单测试上面提到的几种 adapter 的用法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">functor_adapter_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tinystl::vector&lt;<span class="type">int</span>&gt; v1 = tinystl::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    tinystl::<span class="built_in">iota</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出大于5的元素</span></span><br><span class="line">    tinystl::<span class="built_in">copy_if</span>(</span><br><span class="line">        v1.<span class="built_in">begin</span>(), </span><br><span class="line">        v1.<span class="built_in">end</span>(), </span><br><span class="line">        tinystl::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>), </span><br><span class="line">        tinystl::<span class="built_in">bind2nd</span>(tinystl::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6 7 8 9 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出大于2小于7的元素</span></span><br><span class="line">    tinystl::<span class="built_in">copy_if</span>(</span><br><span class="line">        v1.<span class="built_in">begin</span>(), </span><br><span class="line">        v1.<span class="built_in">end</span>(), </span><br><span class="line">        tinystl::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>), </span><br><span class="line">        tinystl::<span class="built_in">compose2</span>(</span><br><span class="line">            tinystl::<span class="built_in">logical_and</span>&lt;<span class="type">bool</span>&gt;(),</span><br><span class="line">            tinystl::<span class="built_in">bind2nd</span>(tinystl::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">2</span>), </span><br><span class="line">            tinystl::<span class="built_in">bind2nd</span>(tinystl::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">7</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 4 5 6 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出小于等于2或者大于等于7的元素</span></span><br><span class="line">    tinystl::<span class="built_in">copy_if</span>(</span><br><span class="line">        v1.<span class="built_in">begin</span>(), </span><br><span class="line">        v1.<span class="built_in">end</span>(), </span><br><span class="line">        tinystl::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>), </span><br><span class="line">        tinystl::<span class="built_in">not1</span>(</span><br><span class="line">            tinystl::<span class="built_in">compose2</span>(</span><br><span class="line">                tinystl::<span class="built_in">logical_and</span>&lt;<span class="type">bool</span>&gt;(),</span><br><span class="line">                tinystl::<span class="built_in">bind2nd</span>(tinystl::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">2</span>), </span><br><span class="line">                tinystl::<span class="built_in">bind2nd</span>(tinystl::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">7</span>)</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0 1 2 7 8 9 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是 <code>not</code>、<code>bind</code>、<code>compose</code> 等的测试，可以看到，拥有了配接能力就是可以为所欲为，可以随意配接直到得到我们想要的表达式，再配合 STL 的一些算法，可以很轻松地处理容器中的内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">in2to7</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &gt; <span class="number">2</span> &amp;&amp; i &lt; <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出大于2小于7的元素</span></span><br><span class="line">tinystl::<span class="built_in">copy_if</span>(</span><br><span class="line">    v1.<span class="built_in">begin</span>(), </span><br><span class="line">    v1.<span class="built_in">end</span>(), </span><br><span class="line">    tinystl::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>), </span><br><span class="line">    tinystl::<span class="built_in">ptr_fun</span>(in2to7)</span><br><span class="line">);</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 4 5 6 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出小于等于2或者大于等于7的元素</span></span><br><span class="line">tinystl::<span class="built_in">copy_if</span>(</span><br><span class="line">    v1.<span class="built_in">begin</span>(), </span><br><span class="line">    v1.<span class="built_in">end</span>(), </span><br><span class="line">    tinystl::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>), </span><br><span class="line">    tinystl::<span class="built_in">not1</span>(tinystl::<span class="built_in">ptr_fun</span>(in2to7))</span><br><span class="line">);</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 1 2 7 8 9 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出小于等于2或者大于等于7的元素</span></span><br><span class="line"><span class="comment">// tinystl::copy_if(</span></span><br><span class="line"><span class="comment">//     v1.begin(), </span></span><br><span class="line"><span class="comment">//     v1.end(), </span></span><br><span class="line"><span class="comment">//     tinystl::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;), </span></span><br><span class="line"><span class="comment">//     tinystl::not1(in2to7)</span></span><br><span class="line"><span class="comment">// );</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>这部分例子测试了 <code>ptr_fun</code> 的功能，可以将普通的函数也修饰为 STL 的仿函数，从而可以进行配接，如果不用 <code>ptr_fun</code> 进行修饰，是无法融入仿函数大家族的，也就没有配接能力。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;draw shape&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;draw circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;draw rectangle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;draw square&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mem_fun_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tinystl::vector&lt;Shape*&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Circle</span>());</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Rectangle</span>());</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Square</span>());</span><br><span class="line"></span><br><span class="line">    tinystl::for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), tinystl::<span class="built_in">mem_fun</span>(&amp;Shape::draw));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// draw circle</span></span><br><span class="line">    <span class="comment">// draw rectangle</span></span><br><span class="line">    <span class="comment">// draw square</span></span><br><span class="line"></span><br><span class="line">    tinystl::for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](Shape *s) &#123; s-&gt;<span class="built_in">draw</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// draw circle</span></span><br><span class="line">    <span class="comment">// draw rectangle</span></span><br><span class="line">    <span class="comment">// draw square</span></span><br><span class="line"></span><br><span class="line">    tinystl::vector&lt;Shape&gt; v1;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">Circle</span>());</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">Rectangle</span>());</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">Square</span>());</span><br><span class="line"></span><br><span class="line">    tinystl::for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), tinystl::<span class="built_in">mem_fun_ref</span>(&amp;Shape::draw));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// draw shape</span></span><br><span class="line">    <span class="comment">// draw shape</span></span><br><span class="line">    <span class="comment">// draw shape</span></span><br><span class="line"></span><br><span class="line">    tinystl::for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), [](Shape &amp;s) &#123; s.<span class="built_in">draw</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// draw shape</span></span><br><span class="line">    <span class="comment">// draw shape</span></span><br><span class="line">    <span class="comment">// draw shape</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分的例子测试了 <code>mem_fun</code> 与 <code>mem_fun_ref</code> 的功能，可以看出，配合多态的特点，<code>for_each</code> 可以做到在遍历过程中的“多态调用（polymorphic function call）”。当然匿名函数也可以做到这一点，只是与上述的结论一样，不再具有配接能力。<code>mem_fun_ref</code> 的测试也是如此。</p>
<p>比较耐人寻味的是两种 <code>for_each</code> 的输出结果，<code>vector&lt;Shape*&gt;</code> 实现了多态调用，而 <code>vector&lt;Shape&gt;</code> 的测试用调用的仍然是父类的 <code>draw()</code> 函数，原因其实比较简单，就是在 <code>v1.push_back(Circle());</code> 时已经发生了隐式类型转换，将所有的插入元素都转换为了 <code>Shape</code> 类型，所以调用 <code>s.draw()</code> 才都会是父类的版本。</p>
<h2 id="总结">总结</h2>
<p>本节主要分析了 adapter 的最后一部分 functor adapter 的内容，functor adapter 是配接器中最为庞大的一个分支，与此相对的，功能也十分强大，可以配接、配接、再配接，直至创造出我们想要的表达式；在 functor adapter 中，<code>ptr_fun</code> 与 <code>mem_fun</code> 及 <code>mem_fun_ref</code> 是比较独特的两类配接器，它们可以将原本不属于 STL 结构中的对象，纳入到 STL 体系中，十分强大。</p>
<p>至此，adapter 部分的内容也就分析完毕了，这也是 STL 中的最后一部分内容，《STL》源码剖析也已经翻到了第 460 页，收工！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://qlipphoth.github.io">Qliphoth</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://qlipphoth.github.io/2023/10/30/2023-10-30-1/">https://qlipphoth.github.io/2023/10/30/2023-10-30-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp</a><a class="post-meta__tags" href="/tags/STL/">STL</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/08/18/cDqb7yXhnK6rkpN.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/29/2023-10-29-1/" title="从零开始的 STL 实现记录：Adapter-1"><img class="cover" src="https://s2.loli.net/2023/08/18/cDqb7yXhnK6rkpN.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">从零开始的 STL 实现记录：Adapter-1</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/10/2023-11-10-1/" title="GASDocumentation 案例项目分析（一）"><img class="cover" src="https://s2.loli.net/2023/11/10/zXw1uyBSA4fYKeL.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">GASDocumentation 案例项目分析（一）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/08/19/2023-8-19-1/" title="从零开始的 STL 实现记录"><img class="cover" src="https://s2.loli.net/2023/08/18/cDqb7yXhnK6rkpN.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-19</div><div class="title">从零开始的 STL 实现记录</div></div></a></div><div><a href="/2023/10/29/2023-10-29-1/" title="从零开始的 STL 实现记录：Adapter-1"><img class="cover" src="https://s2.loli.net/2023/08/18/cDqb7yXhnK6rkpN.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">从零开始的 STL 实现记录：Adapter-1</div></div></a></div><div><a href="/2023/10/25/2023-10-25-1/" title="从零开始的 STL 实现记录：Functor"><img class="cover" src="https://s2.loli.net/2023/08/18/cDqb7yXhnK6rkpN.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-25</div><div class="title">从零开始的 STL 实现记录：Functor</div></div></a></div><div><a href="/2023/10/23/2023-10-23-1/" title="从零开始的 STL 实现记录：Algorithm-4.5"><img class="cover" src="https://s2.loli.net/2023/08/18/cDqb7yXhnK6rkpN.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-23</div><div class="title">从零开始的 STL 实现记录：Algorithm-4.5</div></div></a></div><div><a href="/2023/10/22/2023-10-22-1/" title="从零开始的 STL 实现记录：Algorithm-4.4"><img class="cover" src="https://s2.loli.net/2023/08/18/cDqb7yXhnK6rkpN.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-22</div><div class="title">从零开始的 STL 实现记录：Algorithm-4.4</div></div></a></div><div><a href="/2023/10/21/2023-10-21-1/" title="从零开始的 STL 实现记录：Algorithm-4.3"><img class="cover" src="https://s2.loli.net/2023/08/18/cDqb7yXhnK6rkpN.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-21</div><div class="title">从零开始的 STL 实现记录：Algorithm-4.3</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/08/12/NkcT1PLmZVj5iY3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Qliphoth</div><div class="author-info__description">See You Next Game</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qlipphoth"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/qlipphoth" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/33030427" target="_blank" title="Bilibili"><i class="fab fa-bilibili" style="color: #FB7299;"></i></a><a class="social-icon" href="mailto:1841362281@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BF%9B%E8%A1%8C%E9%80%BB%E8%BE%91%E5%90%A6%E5%AE%9A%EF%BC%9Anot1%E3%80%81not2"><span class="toc-number">2.</span> <span class="toc-text">对返回值进行逻辑否定：not1、not2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E7%BB%91%E5%AE%9A%EF%BC%9Abind1st%E3%80%81bind2nd"><span class="toc-number">3.</span> <span class="toc-text">对参数进行绑定：bind1st、bind2nd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E5%90%88%E6%88%90%EF%BC%9Acompose1%E3%80%81compose2"><span class="toc-number">4.</span> <span class="toc-text">用于函数合成：compose1、compose2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%9Aptr-fun%E3%80%81mem-fun%E3%80%81mem-fun-ref"><span class="toc-number">5.</span> <span class="toc-text">用于函数指针与成员函数指针：ptr_fun、mem_fun、mem_fun_ref</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%9Aptr-fun"><span class="toc-number">5.1.</span> <span class="toc-text">用于函数指针：ptr_fun</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%9Amem-fun%E3%80%81mem-fun-ref"><span class="toc-number">5.2.</span> <span class="toc-text">用于成员函数指针：mem_fun、mem_fun_ref</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">6.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/10/2024-12-10-1/" title="TortoiseSVN 简单入门"><img src="https://s2.loli.net/2023/08/14/mkTFOD8fJbu4VH3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TortoiseSVN 简单入门"/></a><div class="content"><a class="title" href="/2024/12/10/2024-12-10-1/" title="TortoiseSVN 简单入门">TortoiseSVN 简单入门</a><time datetime="2024-12-10T17:21:06.000Z" title="Created 2024-12-10 17:21:06">2024-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/23/2024-11-23-1/" title="Lua 源码解析（二）：基本数据类型 —— 表（下）"><img src="https://s2.loli.net/2024/11/08/NRtroieCAd98Uzp.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lua 源码解析（二）：基本数据类型 —— 表（下）"/></a><div class="content"><a class="title" href="/2024/11/23/2024-11-23-1/" title="Lua 源码解析（二）：基本数据类型 —— 表（下）">Lua 源码解析（二）：基本数据类型 —— 表（下）</a><time datetime="2024-11-23T16:58:19.000Z" title="Created 2024-11-23 16:58:19">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/17/2024-11-17-1/" title="Lua 源码解析（二）：基本数据类型 —— 表（上）"><img src="https://s2.loli.net/2024/11/08/NRtroieCAd98Uzp.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lua 源码解析（二）：基本数据类型 —— 表（上）"/></a><div class="content"><a class="title" href="/2024/11/17/2024-11-17-1/" title="Lua 源码解析（二）：基本数据类型 —— 表（上）">Lua 源码解析（二）：基本数据类型 —— 表（上）</a><time datetime="2024-11-17T16:36:15.000Z" title="Created 2024-11-17 16:36:15">2024-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/15/2024-11-15-1/" title="Lua 源码解析（二）：基本数据类型 —— 字符串"><img src="https://s2.loli.net/2024/11/08/NRtroieCAd98Uzp.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lua 源码解析（二）：基本数据类型 —— 字符串"/></a><div class="content"><a class="title" href="/2024/11/15/2024-11-15-1/" title="Lua 源码解析（二）：基本数据类型 —— 字符串">Lua 源码解析（二）：基本数据类型 —— 字符串</a><time datetime="2024-11-15T16:09:05.000Z" title="Created 2024-11-15 16:09:05">2024-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/14/2024-11-14-1/" title="Lua 源码解析（二）：基本数据类型 —— Lua 中的数据类型"><img src="https://s2.loli.net/2024/11/08/NRtroieCAd98Uzp.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lua 源码解析（二）：基本数据类型 —— Lua 中的数据类型"/></a><div class="content"><a class="title" href="/2024/11/14/2024-11-14-1/" title="Lua 源码解析（二）：基本数据类型 —— Lua 中的数据类型">Lua 源码解析（二）：基本数据类型 —— Lua 中的数据类型</a><time datetime="2024-11-14T15:28:37.000Z" title="Created 2024-11-14 15:28:37">2024-11-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/08/18/cDqb7yXhnK6rkpN.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By Qliphoth</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://qliphoth.netlify.app/.netlify/functions/twikoo',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://qliphoth.netlify.app/.netlify/functions/twikoo',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[image]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[link]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[code]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://qliphoth.netlify.app/.netlify/functions/twikoo',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "Unable to get the data, please make sure the settings are correct."
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += 'No Comment'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="8654234284" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://hexo-api-khaki.vercel.app/api/?user=qlipphoth";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="qlipphoth";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log("已挂载hexo-github-calendar https://github.com/Barry-Flynn/hexo-github-calendar");
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><script data-pjax>function electric_clock_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>';
                console.log('已挂载electric_clock')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='/'|| '/' ==='all')){

            electric_clock_injector_config()
        } </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax  src="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><div id="ghbdages" style="overflow:hidden;max-height:90px;height:auto;text-align:center;margin-top:10px"><div class="swiper-wrapper"><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v5.4.0"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v3.8.2"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></div></div></div><style>a.github-badge:hover:before {display:none}</style>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><script defer src="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js"></script><!-- hexo injector body_end end --></body></html>